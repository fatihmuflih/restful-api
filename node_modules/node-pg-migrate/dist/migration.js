"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var _nodefs = require('node:fs');
var _promises = require('node:fs/promises');
var _nodepath = require('node:path');
var _migrationBuilder = require('./migrationBuilder'); var _migrationBuilder2 = _interopRequireDefault(_migrationBuilder);
var _utils = require('./utils');
var FilenameFormat = /* @__PURE__ */ ((FilenameFormat2) => {
  FilenameFormat2["timestamp"] = "timestamp";
  FilenameFormat2["utc"] = "utc";
  return FilenameFormat2;
})(FilenameFormat || {});
const SEPARATOR = "_";
async function loadMigrationFiles(dir, ignorePattern) {
  const dirContent = await _promises.readdir.call(void 0, `${dir}/`, { withFileTypes: true });
  const files = dirContent.map((file) => file.isFile() || file.isSymbolicLink() ? file.name : null).filter((file) => Boolean(file)).sort();
  const filter = new RegExp(`^(${ignorePattern})$`);
  return ignorePattern === void 0 ? files : files.filter((i) => !filter.test(i));
}
function getSuffixFromFileName(fileName) {
  return _nodepath.extname.call(void 0, fileName).slice(1);
}
async function getLastSuffix(dir, ignorePattern) {
  try {
    const files = await loadMigrationFiles(dir, ignorePattern);
    return files.length > 0 ? getSuffixFromFileName(files[files.length - 1]) : void 0;
  } catch (err) {
    return void 0;
  }
}
function getTimestamp(logger, filename) {
  const prefix = filename.split(SEPARATOR)[0];
  if (prefix && /^\d+$/.test(prefix)) {
    if (prefix.length === 13) {
      return Number(prefix);
    }
    if (prefix && prefix.length === 17) {
      const year = prefix.slice(0, 4);
      const month = prefix.slice(4, 6);
      const date = prefix.slice(6, 8);
      const hours = prefix.slice(8, 10);
      const minutes = prefix.slice(10, 12);
      const seconds = prefix.slice(12, 14);
      const ms = prefix.slice(14, 17);
      return (/* @__PURE__ */ new Date(
        `${year}-${month}-${date}T${hours}:${minutes}:${seconds}.${ms}Z`
      )).valueOf();
    }
  }
  logger.error(`Can't determine timestamp for ${prefix}`);
  return Number(prefix) || 0;
}
async function resolveSuffix(directory, { language, ignorePattern }) {
  return language || await getLastSuffix(directory, ignorePattern) || "js";
}
class Migration {
  // class method that creates a new migration file by cloning the migration template
  static async create(name, directory, options = {}) {
    const { filenameFormat = "timestamp" /* timestamp */ } = options;
    await _promises.mkdir.call(void 0, directory, { recursive: true });
    const now = /* @__PURE__ */ new Date();
    const time = filenameFormat === "utc" /* utc */ ? now.toISOString().replace(/[^\d]/g, "") : now.valueOf();
    const templateFileName = "templateFileName" in options ? _nodepath.resolve.call(void 0, process.cwd(), options.templateFileName) : _nodepath.resolve.call(void 0, 
      __dirname,
      `../templates/migration-template.${await resolveSuffix(directory, options)}`
    );
    const suffix = getSuffixFromFileName(templateFileName);
    const newFile = `${directory}/${time}${SEPARATOR}${name}.${suffix}`;
    await new Promise((resolve2, reject) => {
      _nodefs.createReadStream.call(void 0, templateFileName).pipe(_nodefs.createWriteStream.call(void 0, newFile)).on("close", resolve2).on("error", reject);
    });
    return newFile;
  }
  constructor(db, migrationPath, { up, down }, options, typeShorthands, logger = console) {
    this.db = db;
    this.path = migrationPath;
    this.name = _nodepath.basename.call(void 0, migrationPath, _nodepath.extname.call(void 0, migrationPath));
    this.timestamp = getTimestamp(logger, this.name);
    this.up = up;
    this.down = down;
    this.options = options;
    this.typeShorthands = typeShorthands;
    this.logger = logger;
  }
  _getMarkAsRun(action) {
    const schema = _utils.getMigrationTableSchema.call(void 0, this.options);
    const { migrationsTable } = this.options;
    const { name } = this;
    switch (action) {
      case this.down: {
        this.logger.info(`### MIGRATION ${this.name} (DOWN) ###`);
        return `DELETE FROM "${schema}"."${migrationsTable}" WHERE name='${name}';`;
      }
      case this.up: {
        this.logger.info(`### MIGRATION ${this.name} (UP) ###`);
        return `INSERT INTO "${schema}"."${migrationsTable}" (name, run_on) VALUES ('${name}', NOW());`;
      }
      default: {
        throw new Error("Unknown direction");
      }
    }
  }
  async _apply(action, pgm) {
    if (action.length === 2) {
      await new Promise((resolve2) => {
        action(pgm, resolve2);
      });
    } else {
      await action(pgm);
    }
    const sqlSteps = pgm.getSqlSteps();
    sqlSteps.push(this._getMarkAsRun(action));
    if (!this.options.singleTransaction && pgm.isUsingTransaction()) {
      sqlSteps.unshift("BEGIN;");
      sqlSteps.push("COMMIT;");
    } else if (this.options.singleTransaction && !pgm.isUsingTransaction()) {
      this.logger.warn("#> WARNING: Need to break single transaction! <");
      sqlSteps.unshift("COMMIT;");
      sqlSteps.push("BEGIN;");
    } else if (!this.options.singleTransaction || !pgm.isUsingTransaction()) {
      this.logger.warn(
        "#> WARNING: This migration is not wrapped in a transaction! <"
      );
    }
    if (typeof this.logger.debug === "function") {
      this.logger.debug(`${sqlSteps.join("\n")}

`);
    }
    return sqlSteps.reduce(
      (promise, sql) => promise.then(() => this.options.dryRun || this.db.query(sql)),
      Promise.resolve()
    );
  }
  _getAction(direction) {
    if (direction === "down" && this.down === void 0) {
      this.down = this.up;
    }
    const action = this[direction];
    if (action === false) {
      throw new Error(
        `User has disabled ${direction} migration on file: ${this.name}`
      );
    }
    if (typeof action !== "function") {
      throw new Error(
        `Unknown value for direction: ${direction}. Is the migration ${this.name} exporting a '${direction}' function?`
      );
    }
    return action;
  }
  apply(direction) {
    const pgm = new (0, _migrationBuilder2.default)(
      this.db,
      this.typeShorthands,
      Boolean(this.options.decamelize),
      this.logger
    );
    const action = this._getAction(direction);
    if (this.down === this.up) {
      pgm.enableReverseMode();
    }
    return this._apply(action, pgm);
  }
  markAsRun(direction) {
    return this.db.query(this._getMarkAsRun(this._getAction(direction)));
  }
}





exports.FilenameFormat = FilenameFormat; exports.Migration = Migration; exports.getTimestamp = getTimestamp; exports.loadMigrationFiles = loadMigrationFiles;
